generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String         @id @default(uuid())
  telegramId   String         @unique
  username     String?
  firstName    String?
  lastName     String?
  avatarUrl    String?
  firstVisitAt DateTime?
  lastActiveAt DateTime?
  godModeEnabled Boolean      @default(false)
  homeScreenReminderSent Boolean @default(false)
  friendshipsSent Friendship[] @relation("FriendFrom")
  friendshipsRecv Friendship[] @relation("FriendTo")
  groupMembers GroupMember[]
  groupsCreated Group[]       @relation("GroupCreator")
  expenses     Expense[]      @relation("UserExpenses")
  shares       ExpenseShare[]
  settlementsFrom Settlement[] @relation("SettlementFrom")
  settlementsTo   Settlement[] @relation("SettlementTo")
  purchases    Purchase[]
  notifications Notification[]
  receiptClaims ReceiptItemClaim[]
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
}

model Friendship {
  id          String            @id @default(uuid())
  requesterId String
  addresseeId String
  status      FriendshipStatus  @default(PENDING)
  createdAt   DateTime          @default(now())

  requester User @relation("FriendFrom", fields: [requesterId], references: [id])
  addressee User @relation("FriendTo", fields: [addresseeId], references: [id])

  @@unique([requesterId, addresseeId])
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

model Group {
  id          String        @id @default(uuid())
  name        String
  imageUrl    String?
  settlementCurrency String @default("USD") @map("currency")
  homeCurrency       String?
  fxMode             GroupFxMode @default(FIXED)
  fixedFxRates       Json?
  fixedFxDate        DateTime?
  fixedFxSource      String?
  closedAt           DateTime?
  lastActivityAt     DateTime?
  inviteCode  String        @unique @default(uuid())
  createdById String
  createdAt   DateTime      @default(now())

  createdBy   User @relation("GroupCreator", fields: [createdById], references: [id])
  members     GroupMember[]
  expenses    Expense[]
  settlements Settlement[]
  purchases   Purchase[]
  entitlements Entitlement[]
}

model GroupMember {
  id       String    @id @default(uuid())
  groupId  String
  userId   String
  role     GroupRole @default(MEMBER)
  isActive Boolean   @default(true)
  joinedAt DateTime  @default(now())
  leftAt   DateTime?

  group Group @relation(fields: [groupId], references: [id])
  user  User  @relation(fields: [userId], references: [id])

  @@unique([groupId, userId])
}

enum GroupRole {
  ADMIN
  MEMBER
}

model Expense {
  id          String    @id @default(uuid())
  groupId     String?
  createdById String
  description String
  settlementAmount   Decimal @db.Decimal(12, 2) @map("amount")
  settlementCurrency String  @default("USD") @map("currency")
  originalAmount     Decimal @db.Decimal(12, 2)
  originalCurrency   String
  fxRate             Decimal? @db.Decimal(18, 8)
  fxDate             DateTime?
  fxSource           String?
  isSystem           Boolean @default(false)
  systemType         SystemExpenseType?
  purchaseId         String? @unique
  category    String?
  createdAt   DateTime  @default(now())

  group     Group? @relation(fields: [groupId], references: [id])
  createdBy User   @relation("UserExpenses", fields: [createdById], references: [id])
  shares    ExpenseShare[]
  receipt   Receipt?
}

model ExpenseShare {
  id        String   @id @default(uuid())
  expenseId String
  userId    String
  paid      Decimal  @db.Decimal(12, 2) @default(0)
  owed      Decimal  @db.Decimal(12, 2) @default(0)

  expense Expense @relation(fields: [expenseId], references: [id])
  user    User    @relation(fields: [userId], references: [id])

  @@unique([expenseId, userId])
}

model Product {
  code                     String  @id
  title                    String
  starsPrice               Int
  durationDays             Int
  active                   Boolean @default(true)
  priceBySettlementCurrency Json

  purchases    Purchase[]
  entitlements Entitlement[]
  pricing      ProductPricing?
  promoCodes   PromoCode[]
}

model ProductPricing {
  id                              String              @id @default(uuid())
  productCode                     String              @unique
  globalDiscountType              DiscountType        @default(NONE)
  percentOff                      Int?
  starsPriceOverride              Int?
  priceBySettlementCurrencyOverride Json?
  enabled                         Boolean             @default(false)
  updatedAt                       DateTime            @updatedAt

  product Product @relation(fields: [productCode], references: [code])
}

model PromoCode {
  id                              String       @id @default(uuid())
  code                            String       @unique
  productCode                     String
  discountType                    DiscountType @default(PERCENT)
  percentOff                      Int?
  starsPriceOverride              Int?
  priceBySettlementCurrencyOverride Json?
  enabled                         Boolean      @default(true)
  maxRedemptions                  Int?
  redeemedCount                   Int          @default(0)
  createdAt                       DateTime     @default(now())
  updatedAt                       DateTime     @updatedAt

  product Product @relation(fields: [productCode], references: [code])

  @@index([productCode])
}

enum DiscountType {
  NONE
  PERCENT
  FIXED_OVERRIDE
}

model Purchase {
  id                      String         @id @default(uuid())
  productCode             String
  groupId                 String
  buyerUserId             String
  invoicePayload          String         @unique
  starsAmount             Int
  currency                String
  status                  PurchaseStatus @default(CREATED)
  telegramPaymentChargeId String?        @unique
  splitCost               Boolean        @default(false)
  settlementFeeAmount     Decimal        @db.Decimal(12, 2)
  settlementCurrency      String
  appliedPromoCode        String?
  pricingSnapshot         Json?
  createdAt               DateTime       @default(now())
  paidAt                  DateTime?

  product     Product      @relation(fields: [productCode], references: [code])
  group       Group        @relation(fields: [groupId], references: [id])
  buyer       User         @relation(fields: [buyerUserId], references: [id])
  entitlement Entitlement?

  @@index([groupId])
  @@index([buyerUserId])
  @@index([status])
}

model Entitlement {
  id          String   @id @default(uuid())
  groupId     String
  productCode String
  startsAt    DateTime
  endsAt      DateTime
  purchaseId  String   @unique

  group    Group    @relation(fields: [groupId], references: [id])
  product  Product  @relation(fields: [productCode], references: [code])
  purchase Purchase @relation(fields: [purchaseId], references: [id])

  @@index([groupId, productCode])
  @@index([endsAt])
}

model Settlement {
  id         String   @id @default(uuid())
  fromUserId String
  toUserId   String
  groupId    String?
  amount     Decimal  @db.Decimal(12, 2)
  currency   String   @default("USD")
  note       String?
  createdAt  DateTime @default(now())

  fromUser User   @relation("SettlementFrom", fields: [fromUserId], references: [id])
  toUser   User   @relation("SettlementTo", fields: [toUserId], references: [id])
  group    Group? @relation(fields: [groupId], references: [id])
}

model Notification {
  id        String   @id @default(uuid())
  userId    String
  type      String
  data      Json
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
}

enum GroupFxMode {
  FIXED
}

enum SystemExpenseType {
  TRIP_PASS_FEE
}

enum PurchaseStatus {
  CREATED
  PAID
  CANCELLED
  FAILED
}

// Receipt — чек, привязанный к Expense
model Receipt {
  id          String        @id @default(uuid())
  expenseId   String        @unique
  imageUrl    String?
  totalAmount Decimal       @db.Decimal(12, 2)
  currency    String
  date        DateTime?
  status      ReceiptStatus @default(PENDING)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  expense Expense       @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  items   ReceiptItem[]
}

// ReceiptItem — позиция чека
model ReceiptItem {
  id         String   @id @default(uuid())
  receiptId  String
  name       String
  quantity   Int      @default(1)
  totalPrice Decimal  @db.Decimal(12, 2)
  unitPrice  Decimal? @db.Decimal(12, 2)
  sortOrder  Int      @default(0)

  receipt Receipt           @relation(fields: [receiptId], references: [id], onDelete: Cascade)
  claims  ReceiptItemClaim[]

  @@index([receiptId])
}

// ReceiptItemClaim — кто забрал сколько единиц позиции
model ReceiptItemClaim {
  id            String   @id @default(uuid())
  receiptItemId String
  userId        String
  quantity      Int      @default(1)
  claimedAt     DateTime @default(now())

  receiptItem ReceiptItem @relation(fields: [receiptItemId], references: [id], onDelete: Cascade)
  user        User        @relation(fields: [userId], references: [id])

  @@unique([receiptItemId, userId])
  @@index([userId])
}

enum ReceiptStatus {
  PENDING      // Ожидает распределения
  DISTRIBUTED  // Полностью распределён
  FINALIZED    // Закрыт, расчёты применены
}

// ============ ADMIN PANEL ============

model AdminUser {
  id           String    @id @default(uuid())
  email        String    @unique
  passwordHash String
  role         AdminRole @default(READ_ONLY)
  enabled      Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  auditLogs AdminAuditLog[]
}

enum AdminRole {
  OWNER
  ADMIN
  SUPPORT
  READ_ONLY
}

model AdminAuditLog {
  id          String   @id @default(uuid())
  adminId     String
  adminRole   AdminRole
  action      String
  targetType  String
  targetId    String?
  before      Json?
  after       Json?
  reason      String
  ip          String?
  userAgent   String?
  createdAt   DateTime @default(now())

  admin AdminUser @relation(fields: [adminId], references: [id])

  @@index([adminId])
  @@index([targetType, targetId])
  @@index([createdAt])
}

// Tracking links для отслеживания переходов по реферальным ссылкам бота
model TrackingLink {
  id          String   @id @default(uuid())
  code        String   @unique
  name        String
  description String?
  clickCount  Int      @default(0)
  enabled     Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  clicks TrackingLinkClick[]

  @@index([code])
  @@index([createdAt])
}

model TrackingLinkClick {
  id             String   @id @default(uuid())
  trackingLinkId String
  telegramUserId String?
  createdAt      DateTime @default(now())

  trackingLink TrackingLink @relation(fields: [trackingLinkId], references: [id], onDelete: Cascade)

  @@index([trackingLinkId])
  @@index([createdAt])
}

